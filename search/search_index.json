{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home These pages are my \"bag of tricks\". They contain notes about how to do various common (or sometimes random) software-related things. It is sourced from the Bag of Tricks repository on Github and is built and deployed with MkDocs .","title":"Home"},{"location":"#home","text":"These pages are my \"bag of tricks\". They contain notes about how to do various common (or sometimes random) software-related things. It is sourced from the Bag of Tricks repository on Github and is built and deployed with MkDocs .","title":"Home"},{"location":"csharp/","text":"C# DistinctBy Extension Method The following code shows an extension method for IEnumerable<T> makes a collection distinct by a certain value. public static IEnumerable < TSource > DistinctBy < TSource , TResult >( this IEnumerable < TSource > enumerable , Func < TSource , TResult > selector ) { if ( enumerable == null ) { throw new ArgumentNullException ( nameof ( enumerable )); } if ( selector == null ) { throw new ArgumentNullException ( nameof ( selector )); } HashSet < TResult > set = new HashSet < TResult >(); foreach ( TSource item in enumerable ) { TResult value = selector ( item ); if ( set . Add ( value )) { yield return item ; } } } LINQ Visualization Image source Uninstall Program by Name /// <summary> /// Uninstalls the specified product. /// </summary> public static void UninstallProduct ( string productName ) { ProcessStartInfo uninstallProcessStart = new ProcessStartInfo { FileName = \"msiexec\" , Arguments = $ \"/x {GetProductCode(productName)} /quiet\" }; Process uninstallProcess = Process . Start ( uninstallProcessStart ); uninstallProcess ?. WaitForExit (); } /// <summary> /// Returns the product code of the specified product, or null if it is not installed. /// </summary> public static string GetProductCode ( string productName ) { foreach ( RegistryKey registryKey in EnumerateInstalledProducts ()) { if ( registryKey . GetValue ( \"DisplayName\" )?. ToString () == productName ) { return registryKey . Name . Split ( '\\\\' )?. LastOrDefault (); } } return null ; } /// <summary> /// Enumerates the <see cref=\"RegistryKey\"/> objects for all the installed products. /// </summary> public static IEnumerable < RegistryKey > EnumerateInstalledProducts () { using ( RegistryKey key = Registry . LocalMachine . OpenSubKey ( @\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\" )) { if ( key != null ) { foreach ( string subKeyName in key . GetSubKeyNames ()) { using ( RegistryKey subKey = key . OpenSubKey ( subKeyName )) { if ( subKey != null ) { yield return subKey ; } } } } } using ( RegistryKey key = Registry . LocalMachine . OpenSubKey ( @\"SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\" )) { if ( key != null ) { foreach ( string subKeyName in key . GetSubKeyNames ()) { using ( RegistryKey subKey = key . OpenSubKey ( subKeyName )) { if ( subKey != null ) { yield return subKey ; } } } } } }","title":"C&#35;"},{"location":"csharp/#c","text":"","title":"C&#35;"},{"location":"csharp/#distinctby-extension-method","text":"The following code shows an extension method for IEnumerable<T> makes a collection distinct by a certain value. public static IEnumerable < TSource > DistinctBy < TSource , TResult >( this IEnumerable < TSource > enumerable , Func < TSource , TResult > selector ) { if ( enumerable == null ) { throw new ArgumentNullException ( nameof ( enumerable )); } if ( selector == null ) { throw new ArgumentNullException ( nameof ( selector )); } HashSet < TResult > set = new HashSet < TResult >(); foreach ( TSource item in enumerable ) { TResult value = selector ( item ); if ( set . Add ( value )) { yield return item ; } } }","title":"DistinctBy Extension Method"},{"location":"csharp/#linq-visualization","text":"Image source","title":"LINQ Visualization"},{"location":"csharp/#uninstall-program-by-name","text":"/// <summary> /// Uninstalls the specified product. /// </summary> public static void UninstallProduct ( string productName ) { ProcessStartInfo uninstallProcessStart = new ProcessStartInfo { FileName = \"msiexec\" , Arguments = $ \"/x {GetProductCode(productName)} /quiet\" }; Process uninstallProcess = Process . Start ( uninstallProcessStart ); uninstallProcess ?. WaitForExit (); } /// <summary> /// Returns the product code of the specified product, or null if it is not installed. /// </summary> public static string GetProductCode ( string productName ) { foreach ( RegistryKey registryKey in EnumerateInstalledProducts ()) { if ( registryKey . GetValue ( \"DisplayName\" )?. ToString () == productName ) { return registryKey . Name . Split ( '\\\\' )?. LastOrDefault (); } } return null ; } /// <summary> /// Enumerates the <see cref=\"RegistryKey\"/> objects for all the installed products. /// </summary> public static IEnumerable < RegistryKey > EnumerateInstalledProducts () { using ( RegistryKey key = Registry . LocalMachine . OpenSubKey ( @\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\" )) { if ( key != null ) { foreach ( string subKeyName in key . GetSubKeyNames ()) { using ( RegistryKey subKey = key . OpenSubKey ( subKeyName )) { if ( subKey != null ) { yield return subKey ; } } } } } using ( RegistryKey key = Registry . LocalMachine . OpenSubKey ( @\"SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\" )) { if ( key != null ) { foreach ( string subKeyName in key . GetSubKeyNames ()) { using ( RegistryKey subKey = key . OpenSubKey ( subKeyName )) { if ( subKey != null ) { yield return subKey ; } } } } } }","title":"Uninstall Program by Name"},{"location":"sql-server/","text":"SQL Server Drop Procedure if Exists IF EXISTS ( SELECT 1 FROM sysobjects WHERE id = object_id ( N '[dbo].[proc]' ) AND OBJECTPROPERTY ( id , N 'IsProcedure' ) = 1 ) BEGIN DROP PROCEDURE [ dbo ].[ proc ] END GO Drop Table if Exists IF EXISTS ( SELECT 1 FROM INFORMATION_SCHEMA . TABLES WHERE TABLE_SCHEMA = '<schema>' AND TABLE_NAME = '<table>' ) BEGIN DROP TABLE [ < schema > ].[ < table > ] END GO Get All Database Triggers SELECT TAB . name as TableName , TRIG . name as TriggerName , TRIG . is_disabled AS IsDisabled FROM sys . triggers AS TRIG INNER JOIN sys . tables AS TAB ON TRIG . parent_id = TAB . object_id Insert or Update Row Using MERGE MERGE table_name AS target USING ( SELECT @ var1 , @ var2 , @ var3 ) AS source ( col1 , col2 , col3 ) ON ( target . col1 = source . col1 ) -- Conditions comparing \"target\" and \"source\" WHEN MATCHED THEN UPDATE SET target . col1 = source . col1 -- Update \"target\" from \"source\" WHEN NOT MATCHED BY TARGET THEN INSERT ( col1 , col2 , col3 ) VALUES ( source . col1 , source . col2 , source . col3 ) -- Insert new row from \"source\" SET NOCOUNT ON SET NOCOUNTON prevents the message from showing which contains the number of affected rows. Using this in a stored procedure can significantly improve its performance.","title":"SQL Server"},{"location":"sql-server/#sql-server","text":"","title":"SQL Server"},{"location":"sql-server/#drop-procedure-if-exists","text":"IF EXISTS ( SELECT 1 FROM sysobjects WHERE id = object_id ( N '[dbo].[proc]' ) AND OBJECTPROPERTY ( id , N 'IsProcedure' ) = 1 ) BEGIN DROP PROCEDURE [ dbo ].[ proc ] END GO","title":"Drop Procedure if Exists"},{"location":"sql-server/#drop-table-if-exists","text":"IF EXISTS ( SELECT 1 FROM INFORMATION_SCHEMA . TABLES WHERE TABLE_SCHEMA = '<schema>' AND TABLE_NAME = '<table>' ) BEGIN DROP TABLE [ < schema > ].[ < table > ] END GO","title":"Drop Table if Exists"},{"location":"sql-server/#get-all-database-triggers","text":"SELECT TAB . name as TableName , TRIG . name as TriggerName , TRIG . is_disabled AS IsDisabled FROM sys . triggers AS TRIG INNER JOIN sys . tables AS TAB ON TRIG . parent_id = TAB . object_id","title":"Get All Database Triggers"},{"location":"sql-server/#insert-or-update-row-using-merge","text":"MERGE table_name AS target USING ( SELECT @ var1 , @ var2 , @ var3 ) AS source ( col1 , col2 , col3 ) ON ( target . col1 = source . col1 ) -- Conditions comparing \"target\" and \"source\" WHEN MATCHED THEN UPDATE SET target . col1 = source . col1 -- Update \"target\" from \"source\" WHEN NOT MATCHED BY TARGET THEN INSERT ( col1 , col2 , col3 ) VALUES ( source . col1 , source . col2 , source . col3 ) -- Insert new row from \"source\"","title":"Insert or Update Row Using MERGE"},{"location":"sql-server/#set-nocount-on","text":"SET NOCOUNTON prevents the message from showing which contains the number of affected rows. Using this in a stored procedure can significantly improve its performance.","title":"SET NOCOUNT ON"},{"location":"windows/","text":"Windows Run a Program at Startup Open the Startup folder. Press Windows + R to open Run. Type shell:startup. Add a shortcut to the program to the Startup folder.","title":"Windows"},{"location":"windows/#windows","text":"","title":"Windows"},{"location":"windows/#run-a-program-at-startup","text":"Open the Startup folder. Press Windows + R to open Run. Type shell:startup. Add a shortcut to the program to the Startup folder.","title":"Run a Program at Startup"},{"location":"wpf/","text":"WPF Filtering a Collection Without Modifying It private ObservableCollection < string > myBackingCollection = new ObservableCollection < string >(); public ICollectionView MyCollectionView { get { ICollectionView view = CollectionViewSource . GetDefaultView ( this . myBackingColleciton ); view . Filter = ( obj ) => true ; // Filter delegate return view ; } } Remove Toolbar Grip and Overflow XAML <ToolBarPanel DockPanel.Dock= \"Top\" > <ToolBar ToolBarTray.IsLocked= \"True\" Loaded= \"ToolBar_Loaded\" > <Menu ToolBar.OverflowMode= \"Never\" > <!-- Menu items --> </Menu> </ToolBar> </ToolBarPanel> Code behind private void ToolBar_Loaded ( object sender , RoutedEventArgs e ) { ToolBar toolBar = sender as ToolBar ; var overflowGrid = toolBar . Template . FindName ( \"OverflowGrid\" , toolBar ) as FrameworkElement ; if ( overflowGrid != null ) { overflowGrid . Visibility = Visibility . Collapsed ; } var mainPanelBorder = toolBar . Template . FindName ( \"MainPanelBorder\" , toolBar ) as FrameworkElement ; if ( mainPanelBorder != null ) { mainPanelBorder . Margin = new Thickness (); } } Span All Grid Rows and Columns The following code shows how to make a control span all rows and/or columns of its parent grid, even if the number of rows and columns change. <Grid> <!-- Other stuff in the grid --> <ContentControl Grid.RowSpan= \"{Binding RelativeSource={RelativeSource AncestorType=Grid}, Path=RowDefinitions.Count, Mode=OneWay}\" Grid.ColumnSpan= \"{Binding RelativeSource={RelativeSource AncestorType=Grid}, Path=ColumnDefinitions.Count, Mode=OneWay}\" /> </Grid>","title":"WPF"},{"location":"wpf/#wpf","text":"","title":"WPF"},{"location":"wpf/#filtering-a-collection-without-modifying-it","text":"private ObservableCollection < string > myBackingCollection = new ObservableCollection < string >(); public ICollectionView MyCollectionView { get { ICollectionView view = CollectionViewSource . GetDefaultView ( this . myBackingColleciton ); view . Filter = ( obj ) => true ; // Filter delegate return view ; } }","title":"Filtering a Collection Without Modifying It"},{"location":"wpf/#remove-toolbar-grip-and-overflow","text":"XAML <ToolBarPanel DockPanel.Dock= \"Top\" > <ToolBar ToolBarTray.IsLocked= \"True\" Loaded= \"ToolBar_Loaded\" > <Menu ToolBar.OverflowMode= \"Never\" > <!-- Menu items --> </Menu> </ToolBar> </ToolBarPanel> Code behind private void ToolBar_Loaded ( object sender , RoutedEventArgs e ) { ToolBar toolBar = sender as ToolBar ; var overflowGrid = toolBar . Template . FindName ( \"OverflowGrid\" , toolBar ) as FrameworkElement ; if ( overflowGrid != null ) { overflowGrid . Visibility = Visibility . Collapsed ; } var mainPanelBorder = toolBar . Template . FindName ( \"MainPanelBorder\" , toolBar ) as FrameworkElement ; if ( mainPanelBorder != null ) { mainPanelBorder . Margin = new Thickness (); } }","title":"Remove Toolbar Grip and Overflow"},{"location":"wpf/#span-all-grid-rows-and-columns","text":"The following code shows how to make a control span all rows and/or columns of its parent grid, even if the number of rows and columns change. <Grid> <!-- Other stuff in the grid --> <ContentControl Grid.RowSpan= \"{Binding RelativeSource={RelativeSource AncestorType=Grid}, Path=RowDefinitions.Count, Mode=OneWay}\" Grid.ColumnSpan= \"{Binding RelativeSource={RelativeSource AncestorType=Grid}, Path=ColumnDefinitions.Count, Mode=OneWay}\" /> </Grid>","title":"Span All Grid Rows and Columns"}]}