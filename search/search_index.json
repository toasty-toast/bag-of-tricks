{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Index","title":"Index"},{"location":"#index","text":"","title":"Index"},{"location":"csharp/","text":"C Sharp DistinctBy Extension Method The following code shows an extension method for IEnumerable<T> makes a collection distinct by a certain value. public static IEnumerable < TSource > DistinctBy < TSource , TResult >( this IEnumerable < TSource > enumerable , Func < TSource , TResult > selector ) { if ( enumerable == null ) { throw new ArgumentNullException ( nameof ( enumerable )); } if ( selector == null ) { throw new ArgumentNullException ( nameof ( selector )); } HashSet < TResult > set = new HashSet < TResult >(); foreach ( TSource item in enumerable ) { TResult value = selector ( item ); if ( set . Add ( value )) { yield return item ; } } } LINQ Visualization Image source Uninstall Program by Name /// <summary> /// Uninstalls the specified product. /// </summary> public static void UninstallProduct ( string productName ) { ProcessStartInfo uninstallProcessStart = new ProcessStartInfo { FileName = \"msiexec\" , Arguments = $ \"/x {GetProductCode(productName)} /quiet\" }; Process uninstallProcess = Process . Start ( uninstallProcessStart ); uninstallProcess ?. WaitForExit (); } /// <summary> /// Returns the product code of the specified product, or null if it is not installed. /// </summary> public static string GetProductCode ( string productName ) { foreach ( RegistryKey registryKey in EnumerateInstalledProducts ()) { if ( registryKey . GetValue ( \"DisplayName\" )?. ToString () == productName ) { return registryKey . Name . Split ( '\\\\' )?. LastOrDefault (); } } return null ; } /// <summary> /// Enumerates the <see cref=\"RegistryKey\"/> objects for all the installed products. /// </summary> public static IEnumerable < RegistryKey > EnumerateInstalledProducts () { using ( RegistryKey key = Registry . LocalMachine . OpenSubKey ( @\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\" )) { if ( key != null ) { foreach ( string subKeyName in key . GetSubKeyNames ()) { using ( RegistryKey subKey = key . OpenSubKey ( subKeyName )) { if ( subKey != null ) { yield return subKey ; } } } } } using ( RegistryKey key = Registry . LocalMachine . OpenSubKey ( @\"SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\" )) { if ( key != null ) { foreach ( string subKeyName in key . GetSubKeyNames ()) { using ( RegistryKey subKey = key . OpenSubKey ( subKeyName )) { if ( subKey != null ) { yield return subKey ; } } } } } }","title":"C Sharp"},{"location":"csharp/#c-sharp","text":"","title":"C Sharp"},{"location":"csharp/#distinctby-extension-method","text":"The following code shows an extension method for IEnumerable<T> makes a collection distinct by a certain value. public static IEnumerable < TSource > DistinctBy < TSource , TResult >( this IEnumerable < TSource > enumerable , Func < TSource , TResult > selector ) { if ( enumerable == null ) { throw new ArgumentNullException ( nameof ( enumerable )); } if ( selector == null ) { throw new ArgumentNullException ( nameof ( selector )); } HashSet < TResult > set = new HashSet < TResult >(); foreach ( TSource item in enumerable ) { TResult value = selector ( item ); if ( set . Add ( value )) { yield return item ; } } }","title":"DistinctBy Extension Method"},{"location":"csharp/#linq-visualization","text":"Image source","title":"LINQ Visualization"},{"location":"csharp/#uninstall-program-by-name","text":"/// <summary> /// Uninstalls the specified product. /// </summary> public static void UninstallProduct ( string productName ) { ProcessStartInfo uninstallProcessStart = new ProcessStartInfo { FileName = \"msiexec\" , Arguments = $ \"/x {GetProductCode(productName)} /quiet\" }; Process uninstallProcess = Process . Start ( uninstallProcessStart ); uninstallProcess ?. WaitForExit (); } /// <summary> /// Returns the product code of the specified product, or null if it is not installed. /// </summary> public static string GetProductCode ( string productName ) { foreach ( RegistryKey registryKey in EnumerateInstalledProducts ()) { if ( registryKey . GetValue ( \"DisplayName\" )?. ToString () == productName ) { return registryKey . Name . Split ( '\\\\' )?. LastOrDefault (); } } return null ; } /// <summary> /// Enumerates the <see cref=\"RegistryKey\"/> objects for all the installed products. /// </summary> public static IEnumerable < RegistryKey > EnumerateInstalledProducts () { using ( RegistryKey key = Registry . LocalMachine . OpenSubKey ( @\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\" )) { if ( key != null ) { foreach ( string subKeyName in key . GetSubKeyNames ()) { using ( RegistryKey subKey = key . OpenSubKey ( subKeyName )) { if ( subKey != null ) { yield return subKey ; } } } } } using ( RegistryKey key = Registry . LocalMachine . OpenSubKey ( @\"SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\" )) { if ( key != null ) { foreach ( string subKeyName in key . GetSubKeyNames ()) { using ( RegistryKey subKey = key . OpenSubKey ( subKeyName )) { if ( subKey != null ) { yield return subKey ; } } } } } }","title":"Uninstall Program by Name"},{"location":"wpf/","text":"WPF Filtering a Collection Without Modifying It private ObservableCollection < string > myBackingCollection = new ObservableCollection < string >(); public ICollectionView MyCollectionView { get { ICollectionView view = CollectionViewSource . GetDefaultView ( this . myBackingColleciton ); view . Filter = ( obj ) => true ; // Filter delegate return view ; } } Remove Toolbar Grip and Overflow XAML <ToolBarPanel DockPanel.Dock= \"Top\" > <ToolBar ToolBarTray.IsLocked= \"True\" Loaded= \"ToolBar_Loaded\" > <Menu ToolBar.OverflowMode= \"Never\" > <!-- Menu items --> </Menu> </ToolBar> </ToolBarPanel> Code behind private void ToolBar_Loaded ( object sender , RoutedEventArgs e ) { ToolBar toolBar = sender as ToolBar ; var overflowGrid = toolBar . Template . FindName ( \"OverflowGrid\" , toolBar ) as FrameworkElement ; if ( overflowGrid != null ) { overflowGrid . Visibility = Visibility . Collapsed ; } var mainPanelBorder = toolBar . Template . FindName ( \"MainPanelBorder\" , toolBar ) as FrameworkElement ; if ( mainPanelBorder != null ) { mainPanelBorder . Margin = new Thickness (); } } Span All Grid Rows and Columns The following code shows how to make a control span all rows and/or columns of its parent grid, even if the number of rows and columns change. <Grid> <!-- Other stuff in the grid --> <ContentControl Grid.RowSpan= \"{Binding RelativeSource={RelativeSource AncestorType=Grid}, Path=RowDefinitions.Count, Mode=OneWay}\" Grid.ColumnSpan= \"{Binding RelativeSource={RelativeSource AncestorType=Grid}, Path=ColumnDefinitions.Count, Mode=OneWay}\" /> </Grid>","title":"WPF"},{"location":"wpf/#wpf","text":"","title":"WPF"},{"location":"wpf/#filtering-a-collection-without-modifying-it","text":"private ObservableCollection < string > myBackingCollection = new ObservableCollection < string >(); public ICollectionView MyCollectionView { get { ICollectionView view = CollectionViewSource . GetDefaultView ( this . myBackingColleciton ); view . Filter = ( obj ) => true ; // Filter delegate return view ; } }","title":"Filtering a Collection Without Modifying It"},{"location":"wpf/#remove-toolbar-grip-and-overflow","text":"XAML <ToolBarPanel DockPanel.Dock= \"Top\" > <ToolBar ToolBarTray.IsLocked= \"True\" Loaded= \"ToolBar_Loaded\" > <Menu ToolBar.OverflowMode= \"Never\" > <!-- Menu items --> </Menu> </ToolBar> </ToolBarPanel> Code behind private void ToolBar_Loaded ( object sender , RoutedEventArgs e ) { ToolBar toolBar = sender as ToolBar ; var overflowGrid = toolBar . Template . FindName ( \"OverflowGrid\" , toolBar ) as FrameworkElement ; if ( overflowGrid != null ) { overflowGrid . Visibility = Visibility . Collapsed ; } var mainPanelBorder = toolBar . Template . FindName ( \"MainPanelBorder\" , toolBar ) as FrameworkElement ; if ( mainPanelBorder != null ) { mainPanelBorder . Margin = new Thickness (); } }","title":"Remove Toolbar Grip and Overflow"},{"location":"wpf/#span-all-grid-rows-and-columns","text":"The following code shows how to make a control span all rows and/or columns of its parent grid, even if the number of rows and columns change. <Grid> <!-- Other stuff in the grid --> <ContentControl Grid.RowSpan= \"{Binding RelativeSource={RelativeSource AncestorType=Grid}, Path=RowDefinitions.Count, Mode=OneWay}\" Grid.ColumnSpan= \"{Binding RelativeSource={RelativeSource AncestorType=Grid}, Path=ColumnDefinitions.Count, Mode=OneWay}\" /> </Grid>","title":"Span All Grid Rows and Columns"}]}